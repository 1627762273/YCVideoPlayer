# 基础方法说明
#### 目录介绍
- 01.最简单的播放
- 02.如何切换视频内核
- 03.切换视频模式
- 04.切换视频清晰度
- 05.视频播放监听
- 06.列表中播放处理
- 07.悬浮窗口播放
- 08.其他重要功能Api
- 09.播放多个视频
- 10.VideoPlayer相关Api
- 11.Controller相关Api



### 01.最简单的播放
- 必须需要的四步骤代码如下所示
    ``` java
    //创建基础视频播放器，一般播放器的功能
    BasisVideoController controller = new BasisVideoController(this);
    //设置控制器
    mVideoPlayer.setVideoController(controller);
    //设置视频播放链接地址
    mVideoPlayer.setUrl(url);
    //开始播放
    mVideoPlayer.start();
    ```
- 开始播放
    ``` java
    //播放视频
    videoPlayer.start();
    ```


### 02.如何切换视频内核
- 创建视频播放器
    ``` java
    PlayerFactory playerFactory = IjkPlayerFactory.create();
    IjkVideoPlayer ijkVideoPlayer = (IjkVideoPlayer) playerFactory.createPlayer(this);
    PlayerFactory playerFactory = ExoPlayerFactory.create();
    ExoMediaPlayer exoMediaPlayer = (ExoMediaPlayer) playerFactory.createPlayer(this);
    PlayerFactory playerFactory = MediaPlayerFactory.create();
    AndroidMediaPlayer androidMediaPlayer = (AndroidMediaPlayer) playerFactory.createPlayer(this);
    ```
- 如何配置视频内核
    ``` java
    //播放器配置，注意：此为全局配置，例如下面就是配置ijk内核播放器
    VideoViewManager.setConfig(VideoPlayerConfig.newBuilder()
            .setLogEnabled(true)//调试的时候请打开日志，方便排错
            .setPlayerFactory(IjkPlayerFactory.create())
            .build());
    ```
- 切换视频内核处理代码
    ``` java
    @SuppressLint("SetTextI18n")
    private void setChangeVideoType(@ConstantKeys.PlayerType int type){
        //切换播放核心，不推荐这么做，我这么写只是为了方便测试
        VideoPlayerConfig config = VideoViewManager.getConfig();
        try {
            Field mPlayerFactoryField = config.getClass().getDeclaredField("mPlayerFactory");
            mPlayerFactoryField.setAccessible(true);
            PlayerFactory playerFactory = null;
            switch (type) {
                case ConstantKeys.VideoPlayerType.TYPE_IJK:
                    playerFactory = IjkPlayerFactory.create();
                    mTvTitle.setText("视频内核：" + " (IjkPlayer)");
                    break;
                case ConstantKeys.VideoPlayerType.TYPE_EXO:
                    playerFactory = ExoPlayerFactory.create();
                    mTvTitle.setText("视频内核：" + " (ExoPlayer)");
                    break;
                case ConstantKeys.VideoPlayerType.TYPE_NATIVE:
                    playerFactory = MediaPlayerFactory.create();
                    mTvTitle.setText("视频内核：" + " (MediaPlayer)");
                    break;
                case ConstantKeys.VideoPlayerType.TYPE_RTC:
                    break;
            }
            mPlayerFactoryField.set(config, playerFactory);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    ```


### 03.切换视频模式
- 关于全屏模式相关api
    ``` java
    //进入全屏
    mVideoPlayer.startFullScreen();
    //退出全屏
    mVideoPlayer.stopFullScreen();
    ```
- 关于小窗口播放相关api
    ``` java
    //开启小屏
    mVideoPlayer.startTinyScreen();
    //退出小屏
    mVideoPlayer.stopTinyScreen();
    ```


### 04.切换视频清晰度



### 05.视频播放监听
- 这个分为两部分：第一部分是播放模式监听，第二部分是播放状态监听，暴露给开发者。这里不建议使用0，1，非常不方便简明之意，采用注解限定。
    ```
    mVideoPlayer.setOnStateChangeListener(new OnVideoStateListener() {
        /**
         * 播放模式
         * 普通模式，小窗口模式，正常模式三种其中一种
         * MODE_NORMAL              普通模式
         * MODE_FULL_SCREEN         全屏模式
         * MODE_TINY_WINDOW         小屏模式
         * @param playerState                       播放模式
         */
        @Override
        public void onPlayerStateChanged(int playerState) {
            switch (playerState) {
                case ConstantKeys.PlayMode.MODE_NORMAL:
                    //普通模式
                    break;
                case ConstantKeys.PlayMode.MODE_FULL_SCREEN:
                    //全屏模式
                    break;
                case ConstantKeys.PlayMode.MODE_TINY_WINDOW:
                    //小屏模式
                    break;
            }
        }
    
        /**
         * 播放状态
         * -1               播放错误
         * 0                播放未开始
         * 1                播放准备中
         * 2                播放准备就绪
         * 3                正在播放
         * 4                暂停播放
         * 5                正在缓冲(播放器正在播放时，缓冲区数据不足，进行缓冲，缓冲区数据足够后恢复播放)
         * 6                暂停缓冲(播放器正在播放时，缓冲区数据不足，进行缓冲，此时暂停播放器，继续缓冲，缓冲区数据足够后恢复暂停
         * 7                播放完成
         * 8                开始播放中止
         * @param playState                         播放状态，主要是指播放器的各种状态
         */
        @Override
        public void onPlayStateChanged(int playState) {
            switch (playState) {
                case ConstantKeys.CurrentState.STATE_IDLE:
                    //播放未开始，初始化
                    break;
                case ConstantKeys.CurrentState.STATE_START_ABORT:
                    //开始播放中止
                    break;
                case ConstantKeys.CurrentState.STATE_PREPARING:
                    //播放准备中
                    break;
                case ConstantKeys.CurrentState.STATE_PREPARED:
                    //播放准备就绪
                    break;
                case ConstantKeys.CurrentState.STATE_ERROR:
                    //播放错误
                    break;
                case ConstantKeys.CurrentState.STATE_BUFFERING_PLAYING:
                    //正在缓冲
                    break;
                case ConstantKeys.CurrentState.STATE_PLAYING:
                    //正在播放
                    break;
                case ConstantKeys.CurrentState.STATE_PAUSED:
                    //暂停播放
                    break;
                case ConstantKeys.CurrentState.STATE_BUFFERING_PAUSED:
                    //暂停缓冲
                    break;
                case ConstantKeys.CurrentState.STATE_COMPLETED:
                    //播放完成
                    break;
            }
        }
    });
    ```





### 06.在列表中播放



### 08.其他重要功能Api
- 设置视频播放器背景图，和视频标题。
    ``` java
    //注意，下面这个controller是指BasisVideoController
    //设置视频背景图
    ImageView thumb = controller.getThumb();
    Glide.with(this).load(R.drawable.image_default).into(controller.getThumb());
    //设置视频标题
    controller.setTitle("视频标题");
    ```
- 判断是否锁屏
    ``` java
    //判断是否锁屏
    boolean locked = controller.isLocked();
    //设置是否锁屏
    controller.setLocked(true);
    ```



### 09.播放多个视频
- 这个举一个例子，比如同时播放两个视频，当然这种情况在app中可能比较少
    ``` java
    //必须设置
    player1.setUrl(VOD_URL_1);
    VideoPlayerBuilder.Builder builder = VideoPlayerBuilder.newBuilder();
    builder.setEnableAudioFocus(false);
    VideoPlayerBuilder videoPlayerBuilder = new VideoPlayerBuilder(builder);
    player1.setVideoBuilder(videoPlayerBuilder);
    BasisVideoController controller1 = new BasisVideoController(this);
    player1.setController(controller1);
    mVideoViews.add(player1);
    
    //必须设置
    player2.setUrl(VOD_URL_2);
    VideoPlayerBuilder.Builder builder2 = VideoPlayerBuilder.newBuilder();
    builder.setEnableAudioFocus(false);
    VideoPlayerBuilder videoPlayerBuilder2 = new VideoPlayerBuilder(builder2);
    player2.setVideoBuilder(videoPlayerBuilder2);
    BasisVideoController controller2 = new BasisVideoController(this);
    player2.setController(controller2);
    mVideoViews.add(player2);
    ```
- 那么要是页面切换到后台，如何处理多个视频的暂停功能呢？如下所示：
    ``` java
    @Override
    protected void onPause() {
        super.onPause();
        for (VideoPlayer vv : mVideoViews) {
            vv.pause();
        }
    }
    
    @Override
    protected void onResume() {
        super.onResume();
        for (VideoPlayer vv : mVideoViews) {
            vv.pause();
        }
    }
    
    @Override
    protected void onDestroy() {
        super.onDestroy();
        for (VideoPlayer vv : mVideoViews) {
            vv.release();
        }
    }
    
    @Override
    public void onBackPressed() {
        for (VideoPlayer vv : mVideoViews) {
            if (vv.onBackPressed())
                return;
        }
        super.onBackPressed();
    }
    ```


### 10.VideoPlayer相关Api
- 关于视频播放相关的api如下所示
    ``` java
    //暂停播放
    mVideoPlayer.pause();
    //视频缓冲完毕，准备开始播放时回调
    mVideoPlayer.onPrepared();
    //重新播放
    mVideoPlayer.replay(true);
    //继续播放
    mVideoPlayer.resume();
    //调整播放进度
    mVideoPlayer.seekTo(100);
    //循环播放， 默认不循环播放
    mVideoPlayer.setLooping(true);
    //设置播放速度
    mVideoPlayer.setSpeed(1.1f);
    //设置音量 0.0f-1.0f 之间
    mVideoPlayer.setVolume(1,1);
    //开始播放
    mVideoPlayer.start();
    ```
- 关于视频切换播放模式相关api
    ``` java
    //判断是否处于全屏状态
    boolean fullScreen = mVideoPlayer.isFullScreen();
    //是否是小窗口模式
    boolean tinyScreen = mVideoPlayer.isTinyScreen();
    //进入全屏
    mVideoPlayer.startFullScreen();
    //退出全屏
    mVideoPlayer.stopFullScreen();
    //开启小屏
    mVideoPlayer.startTinyScreen();
    //退出小屏
    mVideoPlayer.stopTinyScreen();
    ```
- 关于其他比如获取速度，音量，设置属性相关Api
    ``` java
    //VideoPlayer相关
    VideoPlayerBuilder.Builder builder = VideoPlayerBuilder.newBuilder();
    VideoPlayerBuilder videoPlayerBuilder = new VideoPlayerBuilder(builder);
    //设置视频播放器的背景色
    builder.setPlayerBackgroundColor(Color.BLACK);
    //设置小屏的宽高
    int[] mTinyScreenSize = {0, 0};
    builder.setTinyScreenSize(mTinyScreenSize);
    //是否开启AudioFocus监听， 默认开启
    builder.setEnableAudioFocus(false);
    mVideoPlayer.setVideoBuilder(videoPlayerBuilder);
    //截图
    Bitmap bitmap = mVideoPlayer.doScreenShot();
    //移除所有播放状态监听
    mVideoPlayer.clearOnStateChangeListeners();
    //获取当前缓冲百分比
    int bufferedPercentage = mVideoPlayer.getBufferedPercentage();
    //获取当前播放器的状态
    int currentPlayerState = mVideoPlayer.getCurrentPlayerState();
    //获取当前的播放状态
    int currentPlayState = mVideoPlayer.getCurrentPlayState();
    //获取当前播放的位置
    long currentPosition = mVideoPlayer.getCurrentPosition();
    //获取视频总时长
    long duration = mVideoPlayer.getDuration();
    //获取倍速速度
    float speed = mVideoPlayer.getSpeed();
    //获取缓冲速度
    long tcpSpeed = mVideoPlayer.getTcpSpeed();
    //获取视频宽高
    int[] videoSize = mVideoPlayer.getVideoSize();
    //是否处于静音状态
    boolean mute = mVideoPlayer.isMute();
    ```


### 11.Controller相关Api
- Controller控制器相关的Api说明
    ``` java
    //设置视频背景图
    ImageView thumb = controller.getThumb();
    Glide.with(this).load(R.drawable.image_default).into(controller.getThumb());
    //设置视频标题
    controller.setTitle("视频标题");
    //添加自定义视图。每添加一个视图，都是方式层级树的最上层
    CustomErrorView customErrorView = new CustomErrorView(this);
    controller.addControlComponent(customErrorView);
    //移除控制组件
    controller.removeControlComponent(customErrorView);
    //移除所有的组件
    controller.removeAllControlComponent();
    //隐藏播放视图
    controller.hide();
    //显示播放视图
    controller.show();
    //是否开启根据屏幕方向进入/退出全屏
    controller.setEnableOrientation(true);
    //显示移动网络播放提示
    controller.showNetWarning();
    //刘海的高度
    int cutoutHeight = controller.getCutoutHeight();
    //是否有刘海屏
    boolean b = controller.hasCutout();
    //设置是否适配刘海屏
    controller.setAdaptCutout(true);
    //停止刷新进度
    controller.stopProgress();
    //开始刷新进度，注意：需在STATE_PLAYING时调用才会开始刷新进度
    controller.startProgress();
    //判断是否锁屏
    boolean locked = controller.isLocked();
    //设置是否锁屏
    controller.setLocked(true);
    //取消计时
    controller.stopFadeOut();
    //开始计时
    controller.startFadeOut();
    //设置播放视图自动隐藏超时
    controller.setDismissTimeout(8);
    //销毁
    controller.destroy();
    ```







- 代码如下所示
    - 在recyclerView中
    ```
    recyclerView.setRecyclerListener(new RecyclerView.RecyclerListener() {
        @Override
        public void onViewRecycled(RecyclerView.ViewHolder holder) {
            VideoPlayer videoPlayer = ((VideoAdapter.VideoViewHolder) holder).mVideoPlayer;
            if (videoPlayer == VideoPlayerManager.instance().getCurrentVideoPlayer()) {
                VideoPlayerManager.instance().releaseVideoPlayer();
            }
        }
    });
    ```
    - 在adapter中，仅仅展示部分代码
    ```
    @Override
    public VideoViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
        View itemView = LayoutInflater.from(mContext).inflate(R.layout.item_test_my_video, parent, false);
        VideoViewHolder holder = new VideoViewHolder(itemView);
        //创建视频播放控制器，主要只要创建一次就可以呢
        VideoPlayerController controller = new VideoPlayerController(mContext);
        holder.setController(controller);
        return holder;
    }

    public class VideoViewHolder extends RecyclerView.ViewHolder {

        public VideoPlayerController mController;
        public VideoPlayer mVideoPlayer;

        VideoViewHolder(View itemView) {
            super(itemView);
            mVideoPlayer = (VideoPlayer) itemView.findViewById(R.id.nice_video_player);
            // 将列表中的每个视频设置为默认16:9的比例
            ViewGroup.LayoutParams params = mVideoPlayer.getLayoutParams();
            // 宽度为屏幕宽度
            params.width = itemView.getResources().getDisplayMetrics().widthPixels;
            // 高度为宽度的9/16
            params.height = (int) (params.width * 9f / 16f);
            mVideoPlayer.setLayoutParams(params);
        }

        /**
         * 设置视频控制器参数
         * @param controller            控制器对象
         */
        void setController(VideoPlayerController controller) {
            mController = controller;
            mVideoPlayer.setPlayerType(ConstantKeys.IjkPlayerType.TYPE_IJK);
            mVideoPlayer.setController(mController);
        }

        void bindData(Video video) {
            mController.setTitle(video.getTitle());
            //mController.setLength(video.getLength());
            ImageUtil.loadImgByPicasso(itemView.getContext(),video.getImageUrl(),R.drawable.image_default,mController.imageView());
            mVideoPlayer.setUp(video.getVideoUrl(), null);
        }
    }
    ```


### 07.在activity播放视频处理home键逻辑
- 代码如下所示
    ```
    private boolean pressedHome;
    private HomeKeyWatcher mHomeKeyWatcher;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        mHomeKeyWatcher = new HomeKeyWatcher(this);
        mHomeKeyWatcher.setOnHomePressedListener(new HomeKeyWatcher.OnHomePressedListener() {
            @Override
            public void onHomePressed() {
                pressedHome = true;
            }
        });
        pressedHome = false;
        mHomeKeyWatcher.startWatch();
    }

    @Override
    protected void onStop() {
        // 在OnStop中是release还是suspend播放器，需要看是不是因为按了Home键
        if (pressedHome) {
            VideoPlayerManager.instance().suspendVideoPlayer();
        } else {
            VideoPlayerManager.instance().releaseVideoPlayer();
        }
        super.onStop();
        mHomeKeyWatcher.stopWatch();
    }

    @Override
    protected void onRestart() {
        mHomeKeyWatcher.startWatch();
        pressedHome = false;
        super.onRestart();
        VideoPlayerManager.instance().resumeVideoPlayer();
    }

    @Override
    public void onBackPressed() {
        if (VideoPlayerManager.instance().onBackPressed()) {
            return;
        }
        super.onBackPressed();
    }
    ```


### 08.在fragment中播放
- 和activity中一样，不同点在于处理fragment返回键逻辑
    ```
    //在宿主Activity中设置代码如下
    @Override
    protected void onStop() {
        super.onStop();
        VideoPlayerManager.instance().releaseVideoPlayer();
    }

    @Override
    public void onBackPressed() {
        if (VideoPlayerManager.instance().onBackPressed()) return;
        super.onBackPressed();
    }

    //--------------------------------------------------

    //在此Fragment中设置代码如下
    @Override
    public void onStop() {
        super.onStop();
        VideoPlayerManager.instance().releaseVideoPlayer();
    }
    ```



### 09.1 显示视频top[分享，下载，更多按钮控件]
- 默认是不显示这几个控件的，一般实际项目中，会对播放器做很多UI方面拓展
    ```
    controller.setTopVisibility(true);
    ```
- 给按钮设置点击事件
    ```
    controller.setOnVideoControlListener(new OnVideoControlListener() {
        @Override
        public void onVideoControlClick(int type) {
            switch (type){
                case ConstantKeys.VideoControl.DOWNLOAD:
                    ToastUtils.showShort("下载");
                    break;
                case ConstantKeys.VideoControl.AUDIO:
                    ToastUtils.showShort("转音频");
                    break;
                case ConstantKeys.VideoControl.SHARE:
                    ToastUtils.showShort("分享");
                    break;
                case ConstantKeys.VideoControl.MENU:
                    ToastUtils.showShort("更多");
                    break;
                case ConstantKeys.VideoControl.TV:
                    ToastUtils.showShort("tv投影");
                    break;
                case ConstantKeys.VideoControl.HOR_AUDIO:
                    ToastUtils.showShort("下载");
                    break;
                default:
                    break;
            }
        }
    });
    ```


### 09.2 显示横屏视频top[tv投影，切换音频控件]
- 默认是不显示这几个控件的，一般实际项目中，会对播放器做很多UI方面拓展
    ```
    //设置横屏播放时，tv和audio图标是否显示
    controller.setTvAndAudioVisibility(true,true);
    ```
- 给按钮设置点击事件
    ```
    controller.setOnVideoControlListener(new OnVideoControlListener() {
        @Override
        public void onVideoControlClick(int type) {
            switch (type){
                case ConstantKeys.VideoControl.TV:
                    BaseToast.showRoundRectToast("投影tv电视");
                    break;
                case ConstantKeys.VideoControl.HOR_AUDIO:
                    BaseToast.showRoundRectToast("切换音频");
                    break;
                default:
                    break;
            }
        }
    });
    ```
    
    
### 10.全局悬浮播放视频
- 代码如下所示
    ```
    @Override
    protected void onDestroy() {
        super.onDestroy();
        /*
         * 这里在返回主页的时候销毁了，因为不想和DEMO中其他页面冲突
         */
        VideoPlayerManager.instance().releaseVideoPlayer();
        FloatWindow.destroy();
    }


    private void startWindow() {
        if (FloatWindow.get() != null) {
            return;
        }
        String url = "http://play.g3proxy.lecloud.com/vod/v2/MjUxLzE2LzgvbGV0di11dHMvMTQvdmVyXzAwXzIyLTExMDc2NDEzODctYXZjLTE5OTgxOS1hYWMtNDgwMDAtNTI2MTEwLTE3MDg3NjEzLWY1OGY2YzM1NjkwZTA2ZGFmYjg2MTVlYzc5MjEyZjU4LTE0OTg1NTc2ODY4MjMubXA0?b=259&mmsid=65565355&tm=1499247143&key=f0eadb4f30c404d49ff8ebad673d3742&platid=3&splatid=345&playid=0&tss=no&vtype=21&cvid=2026135183914&payff=0&pip=08cc52f8b09acd3eff8bf31688ddeced&format=0&sign=mb&dname=mobile&expect=1&tag=mobile&xformat=super";
        FloatPlayerView.setUrl(url);
        FloatPlayerView floatPlayerView = new FloatPlayerView(getApplicationContext());
        floatPlayerView.setCompletedListener(new FloatPlayerView.CompletedListener() {
            @Override
            public void Completed() {
                FloatWindow.get().hide();
            }
        });
        FloatWindow
                .with(getApplicationContext())
                .setView(floatPlayerView)
                //.setWidth(WindowScreen.width, 0.4f)
                //.setHeight(WindowScreen.width, 0.3f)
                .setX(WindowScreen.width, 0.8f)             //这个是设置位置
                .setY(WindowScreen.height, 0.3f)
                .setMoveType(MoveType.slide)
                .setFilter(false)
                //.setFilter(true, WindowActivity.class, EmptyActivity.class)
                .setMoveStyle(500, new BounceInterpolator())
                .build();
        FloatWindow.get().show();
    }
    ```



### 11.常见api说明
#### 11.1 关于VideoPlayer中设置属性方法
- 如下所示
    ```
    //进入全屏模式
    videoPlayer.enterFullScreen();
    //进入竖屏的全屏模式
    videoPlayer.enterVerticalScreenScreen();
    //进入小窗口播放
    //注意：小窗口播放视频比例是        16：9
    videoPlayer.enterTinyWindow();

    //释放，内部的播放器被释放掉，同时如果在全屏、小窗口模式下都会退出
    videoPlayer.release();
    //释放播放器，注意一定要判断对象是否为空，增强严谨性
    videoPlayer.releasePlayer();

    //设置播放器类型，必须设置
    //输入值：ConstantKeys.IjkPlayerType.TYPE_IJK   或者  ConstantKeys.IjkPlayerType.TYPE_NATIVE
    videoPlayer.setPlayerType(ConstantKeys.IjkPlayerType.TYPE_NATIVE);
    //设置播放位置
    videoPlayer.seekTo(100);
    //设置播放速度，不必须
    videoPlayer.setSpeed(100);
    //设置视频链接
    videoPlayer.setUp("",null);
    //设置音量
    videoPlayer.setVolume(50);

    //是否从上一次的位置继续播放
    videoPlayer.continueFromLastPosition(true);
    ```


#### 11.2 关于VideoPlayer中获取属性方法
- 如下所示
    ```
    //关于视频播放相关api
    //获取缓冲区百分比
    int bufferPercentage = videoPlayer.getBufferPercentage();
    //获取播放位置
    long currentPosition = videoPlayer.getCurrentPosition();
    //获取当前播放模式
    int currentState = videoPlayer.getCurrentState();
    //获取持续时长
    long duration = videoPlayer.getDuration();
    //获取最大音量
    int maxVolume = videoPlayer.getMaxVolume();
    //获取当前播放状态
    int playType = videoPlayer.getPlayType();
    //获取播放速度
    long tcpSpeed = videoPlayer.getTcpSpeed();
    //获取音量值
    int volume = videoPlayer.getVolume();
    ```

#### 11.3 关于VideoPlayer中设置播放状态方法
- 如下所示
    ```
    //判断是否是否缓冲暂停
    boolean bufferingPaused = videoPlayer.isBufferingPaused();
    //判断视频是否正在缓冲(播放器正在播放时，缓冲区数据不足，进行缓冲，缓冲区数据足够后恢复播放)
    boolean bufferingPlaying = videoPlayer.isBufferingPlaying();
    //判断视频是否播放完成
    boolean completed = videoPlayer.isCompleted();
    //判断视频是否播放错误
    boolean error = videoPlayer.isError();
    //判断视频是否播放全屏
    boolean fullScreen = videoPlayer.isFullScreen();
    //判断是否开始播放
    boolean idle = videoPlayer.isIdle();
    //判断视频是否正常播放
    boolean normal = videoPlayer.isNormal();
    //判断视频是否暂停播放
    boolean paused = videoPlayer.isPaused();
    //判断视频是否正在播放
    boolean playing = videoPlayer.isPlaying();
    //判断视频是否准备就绪
    boolean prepared = videoPlayer.isPrepared();
    //判断视频是否播放准备中
    boolean preparing = videoPlayer.isPreparing();
    //判断视频是否播放小窗口
    boolean tinyWindow = videoPlayer.isTinyWindow();


    //开始播放
    videoPlayer.start();
    //暂停播放
    videoPlayer.pause();
    //开始播放
    videoPlayer.start(100);
    //重新播放
    videoPlayer.restart();
    ```


#### 11.4 关于controller控制器api
- 如下所示
    ```
    //设置是否显示视频头部的下载，分享，其他等控件是否显示
    controller.setTopVisibility(true);
    controller.setTop(20);
    //设置top到顶部的距离
    controller.setTopPadding(30);
    //设置加载loading类型
    controller.setLoadingType(ConstantKeys.Loading.LOADING_RING);
    //设置不操作后，多久自动隐藏头部和底部布局
    controller.setHideTime(8000);
    //设置中间播放按钮是否显示，并且支持设置自定义图标
    controller.setCenterPlayer(true,R.drawable.image_default);
    //获取ImageView的对象
    ImageView imageView = controller.imageView();
    //重新设置
    controller.reset();
    //设置图片
    controller.setImage(R.drawable.ic_back_right);
    //设置视频时长
    controller.setLength(1000);
    //设置视频标题
    controller.setTitle("小杨逗比");
    boolean lock = controller.getLock();
    //设置横屏播放时，tv和audio图标是否显示
    controller.setTvAndAudioVisibility(true,true);
    //让用户自己处理返回键事件的逻辑
    controller.setOnVideoBackListener(new OnVideoBackListener() {
        @Override
        public void onBackClick() {

        }
    });
    //播放暂停监听事件
    controller.setOnPlayOrPauseListener(new OnPlayOrPauseListener() {
        @Override
        public void onPlayOrPauseClick(boolean isPlaying) {

        }
    });
    //监听视频播放完成事件
    controller.setOnCompletedListener(new OnCompletedListener() {
        @Override
        public void onCompleted() {

        }
    });
    //设置视频分享，下载，音视频转化点击事件
    controller.setOnVideoControlListener(new OnVideoControlListener() {
        @Override
        public void onVideoControlClick(int type) {

        }
    });

    //视频播放模式监听
    controller.setOnPlayerTypeListener(new OnPlayerTypeListener() {
        /**
         * 切换到全屏播放监听
         */
        @Override
        public void onFullScreen() {
            LogUtils.e("setOnPlayerTypeListener"+"onFullScreen");
        }
        /**
         * 切换到小窗口播放监听
         */
        @Override
        public void onTinyWindow() {
            LogUtils.e("setOnPlayerTypeListener"+"onTinyWindow");
        }
        /**
         * 切换到正常播放监听
         */
        @Override
        public void onNormal() {
            LogUtils.e("setOnPlayerTypeListener"+"onNormal");
        }
    });
    ```

#### 11.5 关于视频播放器管理器api
- 如下所示
    ```
    //VideoPlayerManager对象
    VideoPlayerManager instance = VideoPlayerManager.instance();
    //当视频暂停时或者缓冲暂停时，调用该方法重新开启视频播放
    instance.resumeVideoPlayer();
    //当视频正在播放或者正在缓冲时，调用该方法暂停视频
    instance.suspendVideoPlayer();
    //释放，内部的播放器被释放掉，同时如果在全屏、小窗口模式下都会退出
    instance.releaseVideoPlayer();
    //处理返回键逻辑
    //如果是全屏，则退出全屏
    //如果是小窗口，则退出小窗口
    instance.onBackPressed();
    //获取对象
    VideoPlayer currentVideoPlayer = instance.getCurrentVideoPlayer();
    //设置VideoPlayer
    instance.setCurrentVideoPlayer(videoPlayer);
    ```



